<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Beehive Construction Simulation</title>
    <style>
      :root {
        --bg-color: #1a1a1a;
        --panel-bg: rgba(30, 30, 30, 0.85);
        --text-color: #ececec;
        --accent: #fbbf24;
      }

      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: var(--bg-color);
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        color: var(--text-color);
      }

      canvas {
        display: block;
        cursor: crosshair;
      }

      #ui-panel {
        position: absolute;
        top: 20px;
        left: 20px;
        width: 300px;
        background-color: var(--panel-bg);
        padding: 20px;
        border-radius: 12px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        pointer-events: auto;
        transition: opacity 0.3s;
      }

      h1 {
        margin: 0 0 15px 0;
        font-size: 1.4rem;
        color: var(--accent);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        padding-bottom: 10px;
      }

      .control-group {
        margin-bottom: 20px;
      }

      .control-group label {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        font-size: 0.9rem;
        font-weight: 600;
      }

      input[type="range"] {
        width: 100%;
        -webkit-appearance: none;
        background: transparent;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: var(--accent);
        cursor: pointer;
        margin-top: -6px;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
      }

      input[type="range"]::-webkit-slider-runnable-track {
        width: 100%;
        height: 4px;
        cursor: pointer;
        background: #4a4a4a;
        border-radius: 2px;
      }

      .stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        font-size: 0.85rem;
        color: #aaa;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .stat-item strong {
        color: #fff;
        display: block;
        font-size: 1.1rem;
      }

      .legend {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        font-size: 0.75rem;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
      }

      #toggle-ui {
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        color: #555;
        cursor: pointer;
        font-size: 20px;
        z-index: 10;
      }

      .honey-glow {
        animation: glow 2s infinite alternate;
      }
      @keyframes glow {
        from {
          box-shadow: 0 0 5px gold;
        }
        to {
          box-shadow: 0 0 15px gold;
        }
      }
    </style>
  </head>
  <body>
    <div id="ui-panel">
      <h1>Hive Mind Simulator</h1>

      <div class="control-group">
        <label>
          Colony Size (Bees)
          <span id="bee-count-val">10</span>
        </label>
        <input type="range" id="bee-slider" min="0" max="300" value="50" />
      </div>

      <div class="control-group">
        <label>
          Resource Availability
          <span id="res-val">Normal</span>
        </label>
        <input type="range" id="resource-slider" min="1" max="10" value="5" />
        <div style="font-size: 0.75rem; color: #888; margin-top: 4px">
          Affects build speed & honey generation
        </div>
      </div>

      <div class="stats">
        <div class="stat-item">
          <strong id="stat-cells">1</strong>
          Cells Built
        </div>
        <div class="stat-item">
          <strong id="stat-honey">0</strong>
          Honey Stores
        </div>
      </div>

      <div class="legend">
        <div class="legend-item">
          <div
            class="dot"
            style="background: #555; border: 1px solid #888"
          ></div>
          Wax
        </div>
        <div class="legend-item">
          <div class="dot" style="background: #fbbf24"></div>
          Honey
        </div>
        <div class="legend-item">
          <div class="dot" style="background: #fff"></div>
          Bee
        </div>
      </div>
    </div>

    <canvas id="simCanvas"></canvas>

    <script>
      /* --- Configuration & State --- */
      const canvas = document.getElementById("simCanvas");
      const ctx = canvas.getContext("2d");

      const UI = {
        beeSlider: document.getElementById("bee-slider"),
        beeVal: document.getElementById("bee-count-val"),
        resSlider: document.getElementById("resource-slider"),
        resVal: document.getElementById("res-val"),
        statCells: document.getElementById("stat-cells"),
        statHoney: document.getElementById("stat-honey"),
      };

      const CONFIG = {
        hexSize: 16,
        beeSpeed: 2,
        beeWiggle: 0.5,
        buildThreshold: 100, // Effort required to build a cell
        honeyThreshold: 100, // Effort required to fill honey
        resourceMultiplier: 1.0,
      };

      let width, height, centerX, centerY;

      // Grid storage: Key = "q,r", Value = Cell Object
      const grid = new Map();
      const bees = [];
      let honeyCount = 0;

      // Directions for neighbors (Axial coordinates)
      // q = x axis, r = z axis (approx)
      const hexDirections = [
        { q: 1, r: 0 },
        { q: 1, r: -1 },
        { q: 0, r: -1 },
        { q: -1, r: 0 },
        { q: -1, r: 1 },
        { q: 0, r: 1 },
      ];

      /* --- Classes --- */

      class Cell {
        constructor(q, r) {
          this.q = q;
          this.r = r;
          this.x = 0; // Calculated in update
          this.y = 0;

          // 0: Blueprint (potential), 1: Construction, 2: Built, 3: Filled
          this.state = "blueprint";
          this.progress = 0; // 0 to 100

          this.calculatePixelPos();
        }

        calculatePixelPos() {
          // Convert Axial to Pixel
          const size = CONFIG.hexSize;
          this.x = centerX + size * ((3 / 2) * this.q);
          this.y =
            centerY +
            size * ((Math.sqrt(3) / 2) * this.q + Math.sqrt(3) * this.r);
        }

        draw() {
          // Draw Hexagon
          const size = CONFIG.hexSize - 1; // -1 for gap

          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = ((2 * Math.PI) / 6) * i;
            const x_i = this.x + size * Math.cos(angle);
            const y_i = this.y + size * Math.sin(angle);
            if (i === 0) ctx.moveTo(x_i, y_i);
            else ctx.lineTo(x_i, y_i);
          }
          ctx.closePath();

          // Style based on state
          if (this.state === "blueprint") {
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 1;
            ctx.stroke();
          } else if (this.state === "construction") {
            ctx.fillStyle = `rgba(200, 180, 100, ${
              0.2 + (this.progress / CONFIG.buildThreshold) * 0.3
            })`;
            ctx.strokeStyle = "#aa8";
            ctx.fill();
            ctx.stroke();
          } else if (this.state === "built") {
            ctx.fillStyle = "#444"; // Empty dark wax
            ctx.strokeStyle = "#d4a017";
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();
          } else if (this.state === "honey") {
            // Gradient for honey
            const grad = ctx.createRadialGradient(
              this.x,
              this.y,
              2,
              this.x,
              this.y,
              size
            );
            grad.addColorStop(0, "#ffe066");
            grad.addColorStop(1, "#b38600");
            ctx.fillStyle = grad;
            ctx.strokeStyle = "#d4a017";
            ctx.fill();
            ctx.stroke();
          }
        }
      }

      class Bee {
        constructor() {
          this.reset();
          // Start at random position near center to simulate emerging
          this.x = centerX + (Math.random() - 0.5) * 50;
          this.y = centerY + (Math.random() - 0.5) * 50;
        }

        reset() {
          this.state = "idle"; // idle, moving_to_build, building, moving_to_store, storing
          this.target = null; // {x, y, cell}
          this.targetCell = null;
          this.timer = 0;
          this.angle = Math.random() * Math.PI * 2;
        }

        update() {
          // 1. Logic State Machine
          if (this.state === "idle") {
            this.decideTask();
          } else if (this.state === "moving") {
            this.move();
          } else if (this.state === "working") {
            this.work();
          }

          // 2. Physics / Wiggle
          // Add some random noise to movement so they aren't robots
          this.x += (Math.random() - 0.5) * CONFIG.beeWiggle;
          this.y += (Math.random() - 0.5) * CONFIG.beeWiggle;
        }

        decideTask() {
          const rand = Math.random();

          // Priority 1: Build new cells if we have resources
          // Find a 'blueprint' or 'construction' cell
          const buildable = Array.from(grid.values()).filter(
            (c) => c.state === "construction"
          );
          const blueprints = Array.from(grid.values()).filter(
            (c) => c.state === "blueprint"
          );
          const builtEmpty = Array.from(grid.values()).filter(
            (c) => c.state === "built"
          );

          // Logic: Expand if crowded, Fill if built

          // If many blueprints but few construction, start construction
          if (
            blueprints.length > 0 &&
            (Math.random() < 0.3 || buildable.length === 0)
          ) {
            // Pick a random blueprint
            this.targetCell =
              blueprints[Math.floor(Math.random() * blueprints.length)];
            this.targetCell.state = "construction"; // Claim it
            this.state = "moving";
            this.taskType = "build";
            return;
          }

          // If existing construction, help build
          if (buildable.length > 0 && Math.random() < 0.6) {
            this.targetCell =
              buildable[Math.floor(Math.random() * buildable.length)];
            this.state = "moving";
            this.taskType = "build";
            return;
          }

          // If built empty cells exist, make honey
          if (builtEmpty.length > 0) {
            this.targetCell =
              builtEmpty[Math.floor(Math.random() * builtEmpty.length)];
            this.state = "moving";
            this.taskType = "honey";
            return;
          }

          // Fallback: Just wander near center
          this.targetCell = { x: centerX, y: centerY };
          this.state = "moving";
          this.taskType = "idle";
        }

        move() {
          if (!this.targetCell) {
            this.state = "idle";
            return;
          }

          const dx = this.targetCell.x - this.x;
          const dy = this.targetCell.y - this.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 5) {
            // Arrived
            if (this.taskType === "idle") {
              this.state = "idle";
            } else {
              this.state = "working";
              this.timer = 0;
            }
          } else {
            // Move towards
            this.angle = Math.atan2(dy, dx);
            this.x += Math.cos(this.angle) * CONFIG.beeSpeed;
            this.y += Math.sin(this.angle) * CONFIG.beeSpeed;
          }
        }

        work() {
          this.timer += 1 * CONFIG.resourceMultiplier; // Speed depends on slider

          // Visual wiggle while working
          this.x += Math.sin(Date.now() * 0.1) * 0.5;

          // Create sparks/particles? (Simplified for performance)

          if (this.taskType === "build") {
            if (this.targetCell.state !== "construction") {
              // Someone finished it or invalid
              this.state = "idle";
              return;
            }
            this.targetCell.progress += 0.5 * CONFIG.resourceMultiplier;

            if (this.targetCell.progress >= CONFIG.buildThreshold) {
              this.targetCell.state = "built";
              this.targetCell.progress = 0; // Reset for honey filling
              addNeighbors(this.targetCell); // Add new blueprints
              updateStats();
              this.state = "idle";
            }

            // Determine boredom
            if (this.timer > 100) this.state = "idle";
          } else if (this.taskType === "honey") {
            if (this.targetCell.state !== "built") {
              this.state = "idle";
              return;
            }

            // Visually turning into honey
            // We reuse 'progress' for honey fill level
            this.targetCell.progress += 0.8 * CONFIG.resourceMultiplier;

            if (this.targetCell.progress >= CONFIG.honeyThreshold) {
              this.targetCell.state = "honey";
              honeyCount++;
              updateStats();
              this.state = "idle";
            }

            if (this.timer > 100) this.state = "idle";
          }
        }

        draw() {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle + Math.PI / 2); // Face forward

          // Wings
          // FIX: Reduced amplitude to 2.5 and added Math.abs to prevent negative radius error
          const wingFlap = Math.sin(Date.now() * 0.5) * 2.5;
          ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
          ctx.beginPath();
          ctx.ellipse(-3, 0, Math.abs(3 + wingFlap), 6, 0.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(3, 0, Math.abs(3 - wingFlap), 6, -0.5, 0, Math.PI * 2);
          ctx.fill();

          // Body
          ctx.fillStyle = "#fbbf24";
          ctx.beginPath();
          ctx.ellipse(0, 0, 3, 5, 0, 0, Math.PI * 2);
          ctx.fill();

          // Stripes
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(-3, -1);
          ctx.lineTo(3, -1);
          ctx.moveTo(-3, 1);
          ctx.lineTo(3, 1);
          ctx.stroke();

          ctx.restore();
        }
      }

      /* --- Logic Functions --- */

      function getHexKey(q, r) {
        return `${q},${r}`;
      }

      function addNeighbors(cell) {
        for (let dir of hexDirections) {
          const nQ = cell.q + dir.q;
          const nR = cell.r + dir.r;
          const key = getHexKey(nQ, nR);

          if (!grid.has(key)) {
            const newCell = new Cell(nQ, nR);
            grid.set(key, newCell);
          }
        }
      }

      function updateStats() {
        const allCells = Array.from(grid.values());
        const built = allCells.filter(
          (c) => c.state === "built" || c.state === "honey"
        ).length;
        UI.statCells.innerText = built;
        UI.statHoney.innerText = honeyCount;
      }

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        centerX = width / 2;
        centerY = height / 2;

        // Recalculate positions of existing cells
        grid.forEach((cell) => cell.calculatePixelPos());
      }

      function init() {
        window.addEventListener("resize", resize);
        resize();

        // Create center cell
        const centerCell = new Cell(0, 0);
        centerCell.state = "built"; // Start with one valid cell
        grid.set(getHexKey(0, 0), centerCell);
        addNeighbors(centerCell);
        updateStats();

        // Setup Sliders
        UI.beeSlider.addEventListener("input", (e) => {
          const val = parseInt(e.target.value);
          UI.beeVal.innerText = val;
          manageBeePopulation(val);
        });

        UI.resSlider.addEventListener("input", (e) => {
          const val = parseInt(e.target.value);
          // Map 1-10 to text and multiplier
          let text = "Low";
          if (val > 3) text = "Normal";
          if (val > 7) text = "Abundant";
          UI.resVal.innerText = text;
          CONFIG.resourceMultiplier = val / 5; // 0.2 to 2.0
        });

        // Initial bees
        manageBeePopulation(50);

        loop();
      }

      function manageBeePopulation(targetCount) {
        const current = bees.length;
        if (current < targetCount) {
          for (let i = 0; i < targetCount - current; i++) {
            bees.push(new Bee());
          }
        } else if (current > targetCount) {
          bees.splice(targetCount, current - targetCount);
        }
      }

      function loop() {
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(0, 0, width, height);

        // 1. Draw Grid
        // We draw in layers: Blueprints -> Construction -> Built -> Honey
        // for better visual stacking
        const allCells = Array.from(grid.values());

        // Draw connectors/blueprints first (background)
        allCells
          .filter((c) => c.state === "blueprint")
          .forEach((c) => c.draw());
        allCells
          .filter((c) => c.state === "construction")
          .forEach((c) => c.draw());
        allCells.filter((c) => c.state === "built").forEach((c) => c.draw());
        allCells.filter((c) => c.state === "honey").forEach((c) => c.draw());

        // 2. Update & Draw Bees
        bees.forEach((bee) => {
          bee.update();
          bee.draw();
        });

        // 3. Dynamic Grid Management
        // If the grid gets too big and goes off screen, we might want to pan
        // For this demo, we assume the user lets it grow.

        requestAnimationFrame(loop);
      }

      init();
    </script>
  </body>
</html>
